# 02. 데이터 입-출력 구현

### 34. 데이터베이스 개요

논리 데이터 저장소 : 논리적 구조로 조직화한 것

물리 데이터 저장소 :  논리 데이터저장소를 소프트웨어가 운용될 환경의 물리적 특성을 고려해 실제 저장장치에 저장한 것

DBMS 의 필수 기능 3가지

- 정의기능
- 조작기능
- 제어기능

**스키마**

| 종류 | 내용 |
| --- | --- |
| 외부스키마 | 필요로 하는 데이터베이스의 논리 구조 정의 |
| 개념스키마 | 전체 데이터베이스의 논리 구조 |
| 내부스키마 | 물리적 저장장치 입장에서의 데이터베이스 구조 |

### 35. 데이터베이스 설계

| 항목 | 내용 |
| --- | --- |
| 무결성 | 삽입, 삭제, 갱신 후에도 데이터가 제약 조건을 항상 만족하는지 |
| 일관성 | 데이터 사이나 특정 질의의 응답이 처음부터 끝까지 일관될 것 |
| 회복 | 장애 발생 시 직전 상태로 회복할 수 있는지 |
| 보안 | 불법적 데이터 노출 변경 손실에서 보호될 수 있는지 |
| 효율성 | 효율적인지 |
| DB 확장 | 운영에 지장을 주지 않으면서 지속적으로 데이터 추가가 가능한지 |

**DB 설계 순서**

1. 요구 조건 분석
    
    DB를 사용할 사람들로부터 필요한 용도를 파악
    
2. `개념적 설계`(정보 모델링, 개념화)  
    
    현실 세계에 대한 인식을 추상적 개념으로 표현. 개념적 스키마 모델링, E-R 다이어그램 활용
    
3. `논리적 설계`(데이터 모델링)
    
    현실 세계에서 발생하는 자료를 특정 DBMS 가 지원하는 논리적 자료 구조로 변환 시키는 과정
    
4. `물리적 설계`(데이터 구조화)
    
    논리적 구조로 표현된 데이터를 물리적 구조의 데이터로 변환하는 과정
    
5. 데이터베이스 구현

### 데이터 모델의 개념

데이터 모델 구성 요소 : 개체, 속성, 관계

데이터 모델 종류 : 개념적 / 논리적 / 물리적 데이터 모델

데이터 모델에 표시할 요소 : 구조, 연산, 제약 조건

**데이터 모델에 표시할 요소**

| 요소 | 내용 |
| --- | --- |
| 구조 | 논리적으로 표현된 개체 타입들 간의 관계 |
| 연산 | 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세 |
| 제약 조건 | 데이터베이스에 저장될 수 있는 실제 데이터의 논리적 제약 조건 |

 

### 37. 데이터 모델의 구성 요소

| 종류 | 내용 |
| --- | --- |
| 엔티티(개체)
Entity | 데이터베이스에서 표현하려는 것. 개념이나 정보 단위 같은 현실 세계의 대상체 |
| 속성
Attribute | 데이터베이스를 구성하는 가장 작은 논리적 단위.
또한 속성은 엔티티를 구성하는 항목에 해당한다. |
| 차수
Degree | 하나의 릴레이션에 들어가 있는 속성의 수.
유효한 릴레이션의 최소 차수는 1. |
| 관계
Relation | 개체 간의 관계 또는 속성 간의 관계 |
| 튜플
Tuple | 릴레이션(=테이블) 의 각 행 |
| 카디널리티
Cardinality | 릴레이션 튜플의 갯수. 릴레이션에서 튜플의 갯수는 0개 이상이다. |
| 도메인
Domain | 릴레이션에 포함된 각각의 속성등이 가질 수 있는 값들의 집합.
ex) ‘성별’ 이라는 속성의 도메인 값은 ‘남’, ‘여’ 일 것이다.
반면 ‘주민등록번호’ 라는 속성의 도메인 값은 셀 수 없을 것..   |

  

| 종류 | 내용 |
| --- | --- |
| 종속 관계 | 두 개체 사이의 주종관계 표현 |
| 중복 관계 | 두 개체 사이에 2번 이상의 종속 관계 |
| 재귀 관계 | 개체가 자기 자신과 관계를 갖는 것 |
| 배타 관계 | … |

### 39. E-R(개체-관계) 모델

개념적 데이터 모델의 대표격

![download.png](02%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8B%E1%85%B5%E1%86%B8-%E1%84%8E%E1%85%AE%E1%86%AF%E1%84%85%E1%85%A7%E1%86%A8%20%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%E1%86%AB%200b82632eef3e4ee1a319f682fef5797b/download.png)

### 40. 관계형 데이터 베이스의 구조 / 관계형 데이터 모델

`개체`와 `관계`를 모두 `릴레이션`이라는 테이블로 표현하기 때문에 개체를 표현하는 `개체 릴레이션`과 관계를 표현하는 `관계 릴레이션`이 존재한다. 

릴레이션 스키마 : 속성들의 집합 

릴레이션 인스턴스 : 튜플들의 집합

튜플 : 릴레이션을 구성하는 각각의 행. 속성의 모임.

이 중, 중복되지 않은 튜플의 수를 `카디널리티` 라고 한다.

속성 : 데이터베이스를 구성하는 가장 작은 논리적 단위

디그리 또는 차수라고 한다.

도메인 : 하나의 속성이 취할 수 있는 같은 타입의 원자 값들의 집합

예를 들어 성별이라는 속성의 도메인에는 남/여 의 두 가지 값이 있을 수 있다.

### 41. 관계형 데이터베이스의 제약조건 - 키(key)

**종류**

| 종류 | 내용 |
| --- | --- |
| 후보키 | 속성 중 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합.
유일성과 최소성을 만족시켜야 한다. |
| 기본키 | 후보키 중 특별히 선정된 주 키. |
| 대체키 | 후보키가 2 이상일 때 기본키를 제외한 나머지 후보키 |
| 슈퍼키 | 속성들의 집합으로 구성된 키 |
| 외래키 | 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합 |

### 43. 관계대수 및 관계해석

관계대수 : 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어

| 종류 | 특징 | 기호 |
| --- | --- | --- |
| selcet | 튜플 중 선택 조건을 만족하는 부분집합을 구해 새 릴레이션 만들기 |  |
| project | 릴레이션의 열에 해당하는 속성을 추출하는 것 |  |
| join | 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합치는 것 |  |
| division | A 안에 B가 속해 있을 때, A에서 B들을 제외한 차집합을 구하는 것  |  |

관계해석 : 관계 데이터의 연산을 표현하는 방법

### 44. 이상 / 함수적 종속

1. 삽입이상
2. 삭제이상
3. 갱신이상

### 45. 정규화

테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 잉요해 테이블을 무손실 분해하는 과정

1. 제 1정규형

테이블에 속한 모든 속성들의 도메인이 원자값만으로 되어 있는 정규형.

 

1. 제 2정규형

테이블이 제 1정규형인 상태에서 기본키가 아닌 모든 속성이 기본키에 대해서 완전 함수적 종속을 만족하는 정규형

```jsx
완전 함수적 종속(Full Functional Dependency)

완전 함수적 종속이란, 종속자가 기본키에만 종속되며, 
기본키가 여러 속성으로 구성되어 있을경우 기본키를 구성하는 
모든 속성이 포함된 기본키의 부분집합에 종속된 경우입니다.
```

 

1. 제 3정규형

테이블이 제 2정규형인 상태에서 기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수적 종속을 만족하지 않는 정규형

```jsx
이행적 함수 종속(Transitive Functional Dependecy)

릴레이션에서 X, Y, Z라는 3 개의 속성이 있을 때 
X→Y, Y→Z 이란 종속 관계가 있을 경우, X→Z가 성립될 때 
이행적 함수 종속이라고 합니다. 즉, X를 알면 Y를 알고 
그를 통해 Z를 알 수 있는 경우를 말합니다.
```

1. BCNF

테이블에서 모든 결정자가 후보키인 정규형이다.

```jsx
후보키 : 속성 중 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합.
유일성과 최소성을 만족시켜야 한다.
```

**두부이걸다줘?** ====⇒ 

`도` 메인이 원자값

`부` 부분적 함수 종속 제거

`이` 행적 함수 종속 제거

`결` 정자이면서 후보키가 아닌 것 제거

`다` 치 종속 제거

`조` 인 종속성 이용

### 46. 반정규화

반정규화 : 정규화된  데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위

### 49. 트랜잭션 분석 / CRUD 분석

트랜잭션 : 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산

**특징**

`Atomicity` : 원자성 : 트랜잭션의 연산은 DB 에 모두 반영되든가 모두 반영되지 않든가.

`Consistancy` : 일관성 : 트랜잭션이 그 실행을 성공하면 언제나 일관성 있는 데이터 베이스 상태로 변환

`Isolation` : 고립성 : 둘 이상의 트랜잭션이 실행되더라도 각각의 트랜잭션은 상대방에게 영향을 주지 않음

`Durability` : 지속-영속-성 : 완료된 트랜잭션 작업은 이후 영구적으로 반영되어야 함

### 51. 뷰 / 클러스터

뷰 : 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가진 가상 테이블

클러스터 : 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법

### 55. 데이터베이스 보안

암호화-복호화

암호화 기법

- 개인키 암호 방식
- 공개키 암호 방식

### 61. 트리

트리는 정점(노드) 와 선분(브랜치) 을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태

### 62. 이진트리

차수가 2 이하인 노드들로 구성된 트리. 

트리의 운행법

1. preorder(전위표기법)
2. inorder(중위표기법)
3. postorder(후위표기법)

### 63. 정렬(sort)

1. 삽입정렬

이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬하는 방식.

ex)

8, 1, 6, 2, 4 를 삽입정렬한다면?

1) 2번째 위치에 있는 `5` 를 1 ~ 본인의 인덱스-1 만큼 순서대로 비교하면서 그 값이 작다면 해당 위치에 그 값을 넣고 뒤로 미룬다.

⇒ 1, 8, 6, 2, 4

2) 3번째 위치에 있는 `6` 을 1~2번의 인덱스 값과 비교하면서 그 값이 작다면 해당 위치에 그 값을 넣고 뒤로 미룬다.

⇒ 1, 6, 8, 2, 4

3) 4번째… ⇒ 1, 2, 6, 8, 4

4) 5번째 ⇒ 1, 2, 4, 6, 8

1. 선택정렬

최소값을 찾아 첫 번째 레코드 위치에 놓고, 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식

ex) 8, 1, 6, 2, 4

1회차 : 1↔2, 1↔3, 1↔4, 1↔5 순으로 비교하면서 만약 그 값이 작다면 서로 자리를 변경

⇒ 1, 8, 6, 2, 4

2회차 : 2↔3, 2↔4, 2↔5 순으로 비교하면서 위치 변경

⇒ 1, 2, 8, 6, 4

3회차 : 3↔4, 3↔5 순으로 비교

⇒ 1, 2, 4, 8, 6

4회차 : 4↔5 비교

⇒ 1, 2, 4, 6, 8

1. 버블정렬

인접한 두 개의 레코드 키 값을 비교해 그 크기에 따라 레코드 위치를 교환하는 정렬 방식

ex) 8, 1, 6, 2, 4

1회차 : 1↔2, 2↔3, 3↔4, 4↔5 순으로 비교하면서 만약 그 값이 크다면 서로 자리를 변경

⇒ 1, 6, 2, 4, 8

2회차 : 1↔2, 2↔3, 3↔4 순으로 비교하면서 위치 변경

⇒ 1, 2, 4, 6, 8

3회차 : 1↔2, 2↔3 순으로 비교

⇒ 1, 2, 4, 6, 8

4회차 : 1↔2 비교

⇒ 1, 2, 4, 6, 8