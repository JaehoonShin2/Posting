# 04. 서버 프로그램 구현

### 73. 객체지향

객체지향의 구성 요소 : 객체, 클래스, 메시지

객체지향의 특징

- 다형성
- 추상화
- 캡슐화
- 상속

### 74. 객체지향 분석 및 설계

객체 지향 분석 : 사용자의 요구 사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 작업

객체 지향 분석의 방법론

- 럼바우

  - 분석 활동을 객체, 동적, 기능 모델로 나눠 수행
  - 객체 모델링 기법 이라고도 함

  <br>객체 모델링 : 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것
  <br>동적 모델링 : 상태 다이어그램을 이용해 시간의 흐름에 따른 객체 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적 행위를 표현하는 모델링
  <br>기능 모델링 : DFD, 흐름도 기반

- 부치 : 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용
- Jacobson : 유스-케이스를 강조하여 사용

**객체지향 설계 원칙**

| 종류                                                          | 내용                                                                          |
| ------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| 단일 책임 원칙 SRP<br>(Single-responsibility principle)       | 객체는 단 하나의 책임만 가져야 한다                                           |
| 개방-폐쇄 원칙 OCP<br>(Open-Closed principle)                 | 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다             |
| 리스코프 치환 원칙 LSP<br>(Liskov Substitution principle)     | 자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다.              |
| 인터페이스 분리 원칙 ISP<br>(Interface Segregation principle) | 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다. |
| 의존 역전 원칙 DIP<br>(Dependency Inversion principle)        | 의존 관계 성립 시 추상성이 높은 클래스와 의존 관계를 맺어야 한다.             |

`SOILD`

`단일책임/개방폐쇄/리스코프치환/인터페이스분리/의존역전`

### 75. 모듈

모듈 : 모듈화를 통해 분리된 시스템의 각 기능. 모듈의 독립성은 결합도와 응집도에 의해 측정된다.

`내공외제스자` / `기순교절시논우`

결합도 : 모듈 간에 상호 의존하는 정도

**결합도(Coupling)의 종류** (위에서 아래로 내려갈수록 결합도가 약해진다.

| 종류          | 내용                                                                                                                                                                                           |
| ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 내용 결합도   | 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조-수정                                                                                                                                  |
| 공통 결합도   | 공유되는 공통 데이터의 영역을 여러 모듈이 사용할 시.<br>혹은 전역변수를 사용하거나 이를 갱신하는 등의 방식으로 상효작용 시.                                                                    |
| 외부 결합도   | 어떤 모듈에서 선언한 변수를 외부의 다른 모듈에서 참조 시                                                                                                                                       |
| 제어 결합도   | 다른 모듈 내부의 논리적 흐름을 제어하기 위한 제어 신호나 제어 요소 전달<br>하위 모듈에서 상위 모듈로 제어 신호가 이동하여 하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도 현상 발생 시. |
| 스탬프 결합도 | 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달 시                                                                                                                                |
| 자료 결합도   | 모듈 간의 인터페이스가 자료 요소로만 구성될 때                                                                                                                                                 |

응집도 : 모듈 내부 요소들이 서로 관련되어 있는 정도

**응집도(Cohesion)의 종류** (위에서 아래로 내려갈수록 응집도가 약해진다.

| 종류              | 내용                                                                                       |
| ----------------- | ------------------------------------------------------------------------------------------ |
| 기능 응집도       | 모듈 내부의 모든 기능 요소들이 간일 문제와 연관되어 수행될 경우                            |
| 순차 응집도       | 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 활용할 경우    |
| 통신(교환) 응집도 | 동일한 입력과 출력을 사용해 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우            |
| 절차 응집도       | 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우 |
| 시간 응집도       | 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우                         |
| 논리 응집도       | 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우        |
| 우연 응집도       | 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우                                       |

Fan-in : 어떤 모듈을 제어하는 모듈의 수

Fan-out : 어떤 모듈에 의해 제어되는 모듈의 수

### 76. 단위 모듈

단위 모듈 : 한 가지 동작을 수행하는 기능을 모듈로 구현한 것

IPC : 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 언어

단위 모듈 테스트 : 프로그램의 단위 기능으로 구현된 모듈이 정해진 기능을 정확히 수행하는지 검증하는 것, 단위 테스트라고도 불린다. 또한 단위 모듈 테스트의 기준은 단위 모듈에 대한 코드이므로 시스템 수준의 오류는 잡아낼 수 없다.

테스트 케이스 ; 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위한 테스트 항목에 대한 명세.

- 식별자
- 테스트 항목 : 테스트 대상
- 입력 명세 : 입력 데이터 또는 테스트 조건
- 출력 명세 : 예상되는 출력 결과
- 환경 설정 : 필요한 하드웨어나 소프트웨어 환경
- 특수 절차 요구
- 의존성 기술

### 79. 디자인 패턴

디자인 패턴 : 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제.

GOF 의 디자인 패턴은 크게 `생성패턴`, `구조패턴`, `행위패턴` 으로 구분된다.

**생성 패턴**

생성 패턴은 클래스나 객체의 생성과 참조 과정을 정의하는 패턴

| 종류          | 내용                                                                                                                                                                                              |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 추상 팩토리   | 인터페이스를 통해 서로 연관-의존하는 객체들의 글부으로 생성하여 추상적으로 표현                                                                                                                   |
| 빌더          | 작게 분리된 인스턴스를 건축하듯 조합해 객체를 생성                                                                                                                                                |
| 팩토리 메소드 | 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴.<br>상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브클래스가 담당함.                                                          |
| 프로토타입    | 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴                                                                                                                                                |
| 싱글톤        | 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없음<br>클래스 내에서 인스턴스가 하나뿐임을 보장하며 ,불필요한 메모리 낭비를 최소화 할 수 있음 |

**구조 패턴**

구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조를 만드는 패턴

| 종류         | 내용                                                                                                                                            |
| ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| 어댑터       | 호환서이 없늨 클래스의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴                                                              |
| 브릿지       | 구현부에서 추상층을 분리, 서로가 독립적으로 확장할 수 있도록 구상한 패턴                                                                        |
| 컴포지트     | 객체를 트리 구조로 구성.                                                                                                                        |
| 데코레이터   | 객체 간의 결합을 통해 능동적으로 기능을 확장.                                                                                                   |
| 퍼싸드       | Wrapper 클래스 필요. 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴 |
| 플라이웨이트 | 인스턴스가 필요할 때마다 생성하는 것이 아니라 가능한 공유해서 사용함으로써 메모리를 절약하는 패턴                                               |
| 프록시       | 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴                                                            |

**행위 패턴**

클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴

| 종류                        | 내용                                                                                                                                                                                                  |
| --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 책임 연쇄                   | 요청을 처리할 수 있는 각 객체들이 체인으로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어감                                                                                                   |
| 커맨드<br>(command)         | 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴                                                                                                                                                    |
| 인터프리터<br>(interpreter) | 언어에 문법 표현을 정의하는 패턴<br>SQL 이나 통신 프로토콜과 같은 것을 개발할 때 사용                                                                                                                 |
| 반복자<br>(Iterator)        | 자료구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴                                                                                                                      |
| 중재자                      | 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있음                                                                                                                                                   |
| 메멘토                      | 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴<br>Ctrl+Z 와 같은 되돌리기 기능을 개발할 때 주로 이용                    |
| 옵서버                      | 주로 분산 시스템 간의 생성-발행하고 수신할 때 사용                                                                                                                                                    |
| 상태                        | 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리                                                                                                                                                    |
| 전략                        | 동일 계열의 알고리즘들을 개별적으로 캡슐로 하여 상호 교환할 수 있게 정의하는 패턴                                                                                                                     |
| 템플릿 메소드               | 상위클래스에서 골격을 정의하고 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴<br>유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해줌 |
| 방문자                      | 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴<br>분리된 처리 기능은 각 클래스를 방문하여 수행함                                                                    |
